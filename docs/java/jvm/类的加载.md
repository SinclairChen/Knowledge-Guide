当我们编写好java代码运行的时候，首先需要将`.java`文件编译成字节码`.class`文件，然后将这个字节码文件加载到jvm中运行。



![image-20210526154555054](image/image-20210526154555054.png)





## 1. 类加载机制

一个类的完整的生命周期：



![image-20210526163608337](image/image-20210526163608337.png)



而类的加载过程主要是：加载 -> 链接 -> 初始化



### 1.1 加载

就是将字节码`.class`文件通过加载器加载到Java虚拟机的过程。如果找不到二进制字节码文件，就会抛出`NoClassDefFound`

主要分为3步：

1. 通过一个类的全限定名获取定义此类的二进制字节流
2. 将这个字节流所代表的的静态存储结构转换为方法区的运行时数据结构
3. 在java堆中生成一个代表这个类的`java.lang.Class`对象，作为对方法区中这些数据的访问入口



### 1.2 链接

#### 1.2.1 验证

为了保证class文件中的字节流信息符合当前虚拟机的要求，不会危害虚拟机的安全。

1. 文件格式的验证：验证字节流是否符合class文件格式的规范
2. 元数据验证：对字节码描述的信息进行语义分析
3. 字节码验证：通过数据流和控制流分析，确定程序予以是合法的、符合逻辑的
4. 符号引用验证：确保解析动作能正确执行



#### 1.2.2 准备

给类的静态变量（static修饰的变量）分配内存，并进行默认初始化。



例如：

```java
public static int = 1;
```

在准备阶段`i`的值会被初始化为0，后面在类初始化阶段才会执行赋值为1



基本数据类型的默认值：

![基本数据类型的零值](image/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%9B%B6%E5%80%BC.png)



如果是被final修饰的静态常量会被直接赋值



例如：

```
public static final int i = 1;
```

对应的i这个常量，在准备阶段就会被赋值为1。



#### 1.2.3 解析

把类中的符号引用转换为直接引用，也就是解析常量池。



在我们编写的代码中，一个变量引用某个对象，这个引用在class文件中是以符号引用来存储的。在这个阶段就需要将其解析并链接为直接引用（相当于指向实际对象）。如果有了直接引用，那引用的目标必定在堆中存在。



主要有四种：

1. 类或接口的解析
2. 字段解析
3. 类方法解析
4. 接口方法解析





### 1.3 初始化

在jvm规范中，一个类在首次“主动使用”时才执行类初始化



**初始化的过程：**

- 类构造器方法
- static静态变量赋值
- static静态代码块



**类初始化的情况：**

1. 当虚拟机启动时候，初始化用户指定的主类，就是启动执行的main方法所在的类
2. 当遇到new指令时，初始化new指令的目标类，就是new一个类的时候要初始化
3. 遇到调用静态方法的指令时，初始化，该静态方法所在的类
4. 遇到访问静态字段的指令时，初始化，该静态字段所在的类
5. 子类的初始化会触发父类的初始化
6. 如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化
7. 使用发射API对某个类进行反射调用时，初始化这个类
8. 初次调用MethodHandle实例时，初始化该MethodHandle指向的方法所在的类。



**不会初始化(可能会加载)：**

1. 通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化
2. 定义对象数组，不会触发该类的初始化
3. 常量在编译期间会存入调用类的常量池，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类
4. 通过类名获取class对象，不会触发类的初始化
5. 通过class.forName加载指定类时，如果指定参数initialize为false时，也不会触发该类的初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化
6. 通过ClassLoader默认的loadClass方法，也不会触发初始化动作（加载了，但是不初始化）



## 2. 类加载器

在加载阶段，将字节码文件加载到Java虚拟机需要借助类加载器来完成。也就是加载过程中的第一步。



### 2.1 分类

| 名称                    | 说明                                                         |
| ----------------------- | ------------------------------------------------------------ |
| Bootstrap ClassLoader   | 负责加载java的核心类\$JAVA_HOME\$中, jre/lib/rt.jar 里面所有的class或者xbootclassoath选项指定的jar包，主要C++实现，并不继承自java.lang.classloader。是jvm自带的，我们在代码层面无法直接获取到启动类加载器的引用。 |
| Extension ClassLoader   | 负责加载java平台中扩展功能的一些jar包，包括\$JAVA_HOME\$中jre/lib/*.jar或 -Djava.ext.dirs指定目录下的jar包 |
| Application ClassLoader | 负责加载classpath中指定的jar包及    Djava.class.path 所指定目录下的类和 jar包 |
| Custom ClassLoader      | 通过java.lang.ClassLoader的子类自定义加载class，用户自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader。 |



### 2.2 加载器的特点

1. 双亲委派
2. 负责依赖：如果一个加载器在加载某个类的时候，发现这个类依赖于另外几个类或者接口，就会去尝试加载这些依赖项
3. 缓存加载：为了提升加载效率，避免重复加载，一旦某个类被一个类加载器加载过，那么它就会缓存这个加载结果，不会重复加载。



### 2.3 双亲委派机制

每个类都有属于自己的加载器，系统中的ClassLoader在协同工作的时候会按顺序自底向上进行加载，从Custom Cloader 到 Bootstrap ClassLoader 逐层检查，只要某个ClassLoader已经加载了，就表示已经加载了。这是就是双亲委派机制，为了保证所有的类只加载一次。

![image-20210526172142212](image/image-20210526172142212.png)



**好处：**

java类随着加载它的加载器一起具备了一种带有优先级的层次关系。比如，java中的Object类，它存放在rt.jar包中，无论哪个一个加载器都要加载它丢回委派给启动类加载器加载，因此Object在各种类加载环境中都是同一个类。但是如果不采用双亲委派的模式，那么各个加载器都自己加载的话，系统中会存在很多不同的Object类。



**破坏：**可以继承ClassLoader类，然后重写其中的loadClass方法。



### 2.4 在程序运行时添加引用类的几种方式

1. 放到jdk的lib/ext下，或者-Djava.ext.dirs
2. java -cp/classpath或者calss文件放到当前路径
3. 自定义classloader加载
4. 拿到当前执行类的classloader，发射调用addUrl方法添加jar或路径



## 3. 问题

### 3.1 如何排查类的方法不一致的问题

如果我们确定一个jar或者class已经在classpath下，但是却总是提示java.lang.NoSuchMethodError，这是为什么呢？

可能是因为加载了错误的或者重复加载了不同版本的jar包。

